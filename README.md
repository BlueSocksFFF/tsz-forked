![Rust](https://github.com/qsib-cbie/tsz/actions/workflows/rust.yml/badge.svg)


# tsz :: Compact Integral Time-Series Compression

A portable implementation for bit-packing and precise framing on space-constrained systems for periodic time-series integral data.

Inspiration drawn from IC FIFO compression and Gorilla timestamp compression.

## Pros and Cons

✅ `tsz` is designed to lean heavily on delta and delta-delta compression. As shown by Gorilla in practice, data points that change the same way compress very well (96% of timestamps could be represented by 1 bit in the Gorilla block).
Periodic integral data, like those from embedded sensor data, that changes with low noise rates will mostly follow the same compression patterns as the timestamps generated by consitently clocked intervals.

✅ `tsz` is designed to take advantage of the integral data patterns produced by ICs that generate consistent bit-width integral data over time with similar magnitudes of change.

✅ `tsz` is designed to emit framed packets that would be considered very small outside of the embedded space, targetting <255 bytes per block.

❌ `tsz` is not designed to handle osciallating change or irregularly event time streams optimally but can encode that information about as well as uncompressed.

❌ `tsz` is not designed to prioritize (de)compression rates over memory usage or compression ratio.


## Example

The following example encodes 2 timestamps and 4 values. The first timestamp is an SoC uptime ms. The second timestamp is UTC us. The values are 4 channels of int16_t data incrementing slowly and sometimes resetting. Data in this example is collected at 1 Hz.

| soc (uint64_t) | utc (int64_t) | channel0 (int16_t) | channel1 (int16_t) | channel2 (int16_t) | channel3 (int16_t) |
| --- | --- | -------- | -------- | -------- | -------- |
| 250 | 1675465460000000 | 0 | 100 | 200 | 300 |
| 1250 | 1675465461000153 | 2 | 101 | 200 | 299 |
| 2250 | 1675465462000512 | 4 | 103 | 201 | 301 |
| 3251 | 1675465463000913 | 7 | 104 | 202 | 302 |
| 4251 | 1675465464001300 | 9 | 105 | 203 | 303 |

Compresses down by 3.2x in example here, extrapolating to 5.9x per 251 byte packet if example continued.

| soc_bits | utc_bits | channel0_bits | channel1_bits | channel2_bits | channel3_bits |
| --- | --- | -------- | -------- | -------- | -------- |
| 16  | 64 | 8 | 8 | 16 | 16 |
| 17 | 40 | 6 | 6 | 6 | 1 | 6 |
| 1 | 10 | 1 | 6 | 6 | 6 |
| 6 | 10  | 6 | 6 | 1 | 6 |
| 6 | 10 | 6 | 1 | 1 | 1 |

See the docs for more info.

## Benchmarks

Initial benchmark results for compression on M1 Max Pro (not target platform)

Consistent delta and delta-delta compresses faster than continuously changing data.

19000 bytes per iteration yields between 173MiB/s to 960MiB/s on "good" hardware.

```
compress monotontic 500 time:   [109.46 µs 109.77 µs 110.06 µs]
                        change: [-0.2060% +0.0239% +0.2984%] (p = 0.85 > 0.05)
                        No change in performance detected.
Found 18 outliers among 100 measurements (18.00%)
  1 (1.00%) low mild
  5 (5.00%) high mild
  12 (12.00%) high severe

compress linear 500     time:   [19.752 µs 19.791 µs 19.838 µs]
                        change: [+0.0169% +0.2636% +0.4882%] (p = 0.03 < 0.05)
                        Change within noise threshold.
Found 1 outliers among 100 measurements (1.00%)
  1 (1.00%) high severe
```